#!/usr/bin/env python3
"""
PRP (Project Requirements Packager)
A beautiful, minimal tool for tracking project dependencies and creating meta-packages.
"""

import sys
import os
import yaml
import argparse
import subprocess
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any

# ANSI Colors for beautiful output
class Colors:
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    
    # Regular colors
    BBLACK = '\033[30;1m'
    GRAY = '\033[0;37m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    BROWN = '\033[0;33m'
    YELLOW = '\033[33;1m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    
    # Bright colors
    BRED = '\033[91m'
    BGREEN = '\033[92m'
    BYELLOW = '\033[93m'
    BBLUE = '\033[94m'
    BMAGENTA = '\033[95m'
    BCYAN = '\033[96m'
    BWHITE = '\033[97m'

c = Colors()

class PRPState:
    """Manages the .prp/state.yaml file"""
    
    def __init__(self, project_dir: Path = None):
        self.project_dir = project_dir or Path.cwd()
        self.prp_dir = self.project_dir / '.prp'
        self.state_file = self.prp_dir / 'state.yaml'
        self._state = None
    
    @property
    def exists(self) -> bool:
        return self.state_file.exists()
    
    def load(self) -> Dict[str, Any]:
        """Load state from file, return empty state if doesn't exist"""
        if not self.exists:
            return self._default_state()
        
        try:
            with open(self.state_file, 'r') as f:
                self._state = yaml.safe_load(f) or self._default_state()
                return self._state
        except Exception as e:
            print(f"{c.RED}Error reading .prp/state.yaml: {e}{c.RESET}")
            return self._default_state()
    
    def save(self, state: Dict[str, Any]):
        """Save state to file"""
        self.prp_dir.mkdir(exist_ok=True)
        try:
            with open(self.state_file, 'w') as f:
                yaml.dump(state, f, default_flow_style=False, sort_keys=False)
            self._state = state
        except Exception as e:
            print(f"{c.RED}Error writing .prp/state.yaml: {e}{c.RESET}")
            sys.exit(1)
    
    def _default_state(self) -> Dict[str, Any]:
        return {
            'project': {
                'name': '',
                'package_name': '',
                'created': '',
                'platform': 'debian'
            },
            'dependencies': [],
            'tentative': [],
            'cleanup': [],
            'original_state': {},  # Track pre-project package states
            'meta_package': {
                'version': '1.0',
                'maintainer': 'Auto Generated <noreply@localhost>',
                'installed': False,
                'last_built': None
            }
        }

class DebianPlatform:
    """Debian/Ubuntu platform implementation"""
    
    @staticmethod
    def is_available() -> bool:
        return Path('/etc/debian_version').exists()
    
    def package_exists(self, package_name: str) -> bool:
        """Check if package exists in repositories"""
        try:
            # Clean the package name (remove any whitespace)
            clean_name = package_name.strip()
            result = subprocess.run(['apt-cache', 'show', clean_name], 
                                  capture_output=True, text=True)
            
            # Debug output to see what's happening
            if result.returncode != 0:
                print(f"{c.DIM}   DEBUG: apt-cache show {clean_name} failed with return code {result.returncode}{c.RESET}")
                print(f"{c.DIM}   DEBUG: stderr: {result.stderr.strip()}{c.RESET}")
                
                # Try alternative method: apt-cache search
                result2 = subprocess.run(['apt-cache', 'search', f'^{clean_name}$'], 
                                       capture_output=True, text=True)
                if result2.returncode == 0 and clean_name in result2.stdout:
                    print(f"{c.DIM}   DEBUG: Found via apt-cache search, using that instead{c.RESET}")
                    return True
            
            return result.returncode == 0
        except Exception as e:
            print(f"{c.DIM}   DEBUG: Exception in package_exists: {e}{c.RESET}")
            return False
    
    def package_status(self, package_name: str):
        """Return (is_installed, is_manual)"""
        try:
            # Clean the package name
            clean_name = package_name.strip()
            
            # Check if installed
            result = subprocess.run(['dpkg', '-l', clean_name], 
                                  capture_output=True, text=True)
            is_installed = result.returncode == 0 and 'ii' in result.stdout
            
            if not is_installed:
                return False, False
            
            # Check if manually installed
            result = subprocess.run(['apt-mark', 'showmanual', clean_name], 
                                  capture_output=True, text=True)
            is_manual = clean_name in result.stdout.strip().split('\n')
            
            return is_installed, is_manual
        except:
            return False, False
    
    def install_package_apt(self, package_name: str) -> bool:
        """Install package using apt. Returns True if successful."""
        try:
            clean_name = package_name.strip()
            print(f"{c.BLUE}Installing {clean_name} with apt...{c.RESET}")
            
            cmd = ['sudo', 'apt', 'install', '-y', clean_name]
            result = subprocess.run(cmd)
            
            if result.returncode == 0:
                print(f"{c.GREEN}Successfully installed {clean_name}{c.RESET}")
                return True
            else:
                print(f"{c.RED}Failed to install {clean_name}{c.RESET}")
                return False
        except Exception as e:
            print(f"{c.RED}Error installing {clean_name}: {e}{c.RESET}")
            return False
    
    def build_meta_package(self, name: str, deps: List[str], version: str, maintainer: str) -> Path:
        """Build meta-package using equivs-build"""
        if not deps:
            raise ValueError("No dependencies to package")
        
        # Create control file
        control_content = f"""Section: misc
Priority: optional
Standards-Version: 4.1.4

Package: {name}
Version: {version}
Maintainer: {maintainer}
Depends: {', '.join(deps)}
Description: Auto-generated meta-package for project dependencies
 This package pulls in all required dependencies for the project.
"""
        
        control_file = Path(f"{name}.control")
        with open(control_file, 'w') as f:
            f.write(control_content)
        
        try:
            # Build the package
            result = subprocess.run(['equivs-build', str(control_file)], 
                                  capture_output=True, text=True)
            if result.returncode != 0:
                raise RuntimeError(f"equivs-build failed: {result.stderr}")
            
            # Find the generated .deb file
            deb_files = list(Path('.').glob(f"{name}_*.deb"))
            if not deb_files:
                raise RuntimeError("No .deb file generated")
            
            return deb_files[0]
        finally:
            # Clean up control file
            if control_file.exists():
                control_file.unlink()
    
    def install_package(self, deb_file: Path):
        """Install a .deb package"""
        cmd = ['sudo', 'dpkg', '-i', str(deb_file)]
        result = subprocess.run(cmd)
        if result.returncode != 0:
            print(f"{c.YELLOW}Running apt-get install -f to fix dependencies...{c.RESET}")
            subprocess.run(['sudo', 'apt-get', 'install', '-f'])
    
    def remove_package(self, package_name: str):
        """Remove a package"""
        cmd = ['sudo', 'apt-get', 'remove', package_name]
        subprocess.run(cmd)
    
    def mark_auto(self, packages: List[str]):
        """Mark packages as automatically installed"""
        if packages:
            cmd = ['sudo', 'apt-mark', 'auto'] + packages
            subprocess.run(cmd)

class PRP:
    """Main PRP application"""
    
    def __init__(self):
        self.state_manager = PRPState()
        self.platform = DebianPlatform() if DebianPlatform.is_available() else None
        if not self.platform:
            print(f"{c.RED}Error: Only Debian/Ubuntu systems are currently supported{c.RESET}")
            sys.exit(1)
    
    def cmd_new(self, project_name: str):
        """Create new project"""
        if self.state_manager.exists:
            print(f"{c.RED}Error: .prp/ already exists{c.RESET}")
            print(f"{c.DIM}Hint: Use 'prp s' to see current project or 'rm -rf .prp' to start over{c.RESET}")
            return
        
        package_name = f"{project_name}-deps"
        state = self.state_manager.load()
        state['project'].update({
            'name': project_name,
            'package_name': package_name,
            'created': datetime.now().isoformat(),
            'platform': 'debian'
        })
        
        self.state_manager.save(state)
        
        print(f"{c.GREEN}Set '{project_name}' as current project name for equivs/dependencies.{c.RESET}")
        print(f"{c.BLUE}System detected as Debian.{c.RESET}")
        print(f"{c.BLUE}Package named appropriately as '{package_name}'{c.RESET}")
        print(f"{c.GREEN}Created: ./.prp/state.yaml{c.RESET}")
    
    def cmd_track(self, package_names: List[str], update: bool = False, no_install: bool = False):
        """Track packages, record their current state, and optionally install them"""
        state = self.state_manager.load()
        
        if not state['project']['name']:
            print(f"{c.RED}Error: No project initialized{c.RESET}")
            print(f"{c.DIM}Hint: Run 'prp n PROJECT_NAME' first{c.RESET}")
            return
        
        if 'original_state' not in state:
            state['original_state'] = {}
        
        state_changed = False
        packages_to_install = []
        
        for package_name in package_names:
            clean_name = package_name.strip()
            print(f"{c.BLUE}Recording current state of {clean_name}...{c.RESET}")
            
            # Check current state
            is_installed, is_manual = self.platform.package_status(clean_name)
            
            # Record or update original state
            if clean_name not in state['original_state'] or update:
                state['original_state'][clean_name] = {  # Use clean_name as key
                    'was_installed': is_installed,
                    'was_manual': is_manual
                }
                
                if is_installed:
                    status_desc = "manually installed" if is_manual else "auto-installed"
                    action = "updated" if update else "recorded"
                    print(f"{c.YELLOW}   {clean_name} is currently {status_desc} - {action}{c.RESET}")
                else:
                    action = "updated" if update else "recorded"
                    print(f"{c.YELLOW}   {clean_name} is not installed - {action}{c.RESET}")
                    # Mark for installation if not installed and not no_install flag
                    if not no_install:
                        packages_to_install.append(clean_name)
                state_changed = True
            else:
                orig = state['original_state'][clean_name]  # Use clean_name for lookup
                if orig['was_installed']:
                    status_desc = "manually installed" if orig['was_manual'] else "auto-installed"
                    print(f"{c.DIM}   {clean_name} original state: was {status_desc} (use --update to refresh){c.RESET}")
                else:
                    print(f"{c.DIM}   {clean_name} original state: was not installed (use --update to refresh){c.RESET}")
                    # Mark for installation if not currently installed and not no_install flag
                    current_installed, _ = self.platform.package_status(clean_name)
                    if not current_installed and not no_install:
                        packages_to_install.append(clean_name)
            
            # Add to tentative list if not already in dependencies
            if clean_name not in state['dependencies']:
                if clean_name not in state['tentative']:
                    state['tentative'].append(clean_name)  # Use clean_name, not package_name!
                    print(f"{c.CYAN}   Added to tentative list{c.RESET}")
                    state_changed = True
                else:
                    print(f"{c.DIM}   Already in tentative list{c.RESET}")
            else:
                print(f"{c.GREEN}   Already in dependencies{c.RESET}")
        
        # Install packages if needed
        if packages_to_install:
            print(f"\n{c.BLUE}Installing {len(packages_to_install)} package(s)...{c.RESET}")
            
            for pkg in packages_to_install:
                # Check if package exists in repositories before installing
                if self.platform.package_exists(pkg):
                    success = self.platform.install_package_apt(pkg)
                    if success:
                        # Update the state to reflect that it's now installed
                        is_installed, is_manual = self.platform.package_status(pkg)
                        if pkg in state['original_state']:
                            # Keep the original was_installed state, but note it's now installed
                            print(f"{c.DIM}   Package {pkg} now installed (originally was not){c.RESET}")
                    else:
                        print(f"{c.YELLOW}   Failed to install {pkg}, continuing with tracking{c.RESET}")
                else:
                    print(f"{c.YELLOW}   {pkg} not found in repositories, skipping installation{c.RESET}")
        elif not no_install:
            print(f"{c.GREEN}All tracked packages are already installed{c.RESET}")
        
        if state_changed:
            self.state_manager.save(state)
            
        print(f"\n{c.GREEN}State tracking complete{c.RESET}")
        if no_install:
            print(f"{c.DIM}Packages were tracked but not installed (--no-install used){c.RESET}")
        print(f"{c.DIM}Use 'prp a' to add tentative packages to dependencies{c.RESET}")
    
    def cmd_add_tentative(self):
        """Add all tentative packages to dependencies"""
        state = self.state_manager.load()
        
        if not state['project']['name']:
            print(f"{c.RED}Error: No project initialized{c.RESET}")
            return
            
        if not state['tentative']:
            print(f"{c.YELLOW}No tentative packages to add{c.RESET}")
            return
        
        # Debug: show what's actually in tentative
        print(f"{c.DIM}DEBUG: Raw tentative list: {state['tentative']}{c.RESET}")
        
        tentative = [pkg.strip() for pkg in state['tentative']]  # Clean package names
        print(f"{c.DIM}DEBUG: Cleaned tentative list: {tentative}{c.RESET}")
            
        print(f"{c.BLUE}Adding all {len(tentative)} tentative packages...{c.RESET}")
        self.cmd_add(tentative, force=False, manual=False, no_auto=False)
    
    def cmd_add(self, package_names: List[str], force: bool = False, manual: bool = False, no_auto: bool = False):
        """Add packages to dependencies"""
        state = self.state_manager.load()
        
        if not state['project']['name']:
            print(f"{c.RED}Error: No project initialized{c.RESET}")
            print(f"{c.DIM}Hint: Run 'prp n PROJECT_NAME' first{c.RESET}")
            return
        
        if 'original_state' not in state:
            state['original_state'] = {}
        
        packages_to_mark_auto = []
        state_changed = False
        
        for package_name in package_names:
            # Clean package name
            clean_name = package_name.strip()
            print(f"\n{c.BLUE}Processing {clean_name}...{c.RESET}")
            
            # Check if already in dependencies first (skip repo check if so)
            if clean_name in state['dependencies']:
                print(f"{c.YELLOW}   {clean_name} already in dependencies{c.RESET}")
                # Still move from tentative if needed
                if clean_name in state['tentative']:
                    state['tentative'].remove(clean_name)
                    print(f"{c.BGREEN}   {clean_name} removed from tentative list{c.RESET}")
                    state_changed = True
                continue
            
            # Record original state if not already recorded
            if clean_name not in state['original_state']:
                is_installed, is_manual = self.platform.package_status(clean_name)
                state['original_state'][clean_name] = {  # Use clean_name as key
                    'was_installed': is_installed,
                    'was_manual': is_manual
                }
                print(f"{c.DIM}   Recording original state: installed={is_installed}, manual={is_manual}{c.RESET}")
            
            # Check if package exists in repositories
            pkg_exists = self.platform.package_exists(clean_name)
            if not pkg_exists and not force:
                print(f"{c.RED}   {clean_name} not found in APT repositories{c.RESET}")
                print(f"{c.DIM}   Use -f / --force to add it anyway (for PPA/custom packages){c.RESET}")
                continue
            elif not pkg_exists and force:
                print(f"{c.YELLOW}   {clean_name} not found in repositories but forcing addition{c.RESET}")
            
            # Check current installation status
            if pkg_exists:
                is_installed, is_manual = self.platform.package_status(clean_name)
                original = state['original_state'][clean_name]
                
                if is_installed:
                    if is_manual and not no_auto and not manual:
                        # Only mark as auto if it wasn't originally manually installed
                        if not original['was_manual']:
                            packages_to_mark_auto.append(clean_name)
                            print(f"{c.YELLOW}   {clean_name} is manually installed (will mark as auto){c.RESET}")
                        else:
                            print(f"{c.YELLOW}   {clean_name} is manually installed (was manual before project - keeping manual){c.RESET}")
                    elif is_manual and (manual or original['was_manual']):
                        print(f"{c.YELLOW}   {clean_name} is manually installed (keeping as manual){c.RESET}")
                    elif is_manual and no_auto:
                        print(f"{c.YELLOW}   {clean_name} is manually installed (not changing status){c.RESET}")
                    else:
                        print(f"{c.GREEN}   {clean_name} is auto-installed{c.RESET}")
                else:
                    print(f"{c.YELLOW}   {clean_name} is not currently installed{c.RESET}")
            
            # Move from tentative if it was there
            if clean_name in state['tentative']:
                state['tentative'].remove(clean_name)
                print(f"{c.BGREEN}   {clean_name} moved from tentative to dependencies{c.RESET}")
                state_changed = True
            
            if clean_name not in state['dependencies']:
                state['dependencies'].append(clean_name)
                print(f"{c.BGREEN}   {clean_name} added to dependencies{c.RESET}")
                state_changed = True
        
        # Mark packages as auto in batch
        if packages_to_mark_auto:
            print(f"\n{c.BLUE}Marking {len(packages_to_mark_auto)} packages as auto-installed...{c.RESET}")
            self.platform.mark_auto(packages_to_mark_auto)
            print(f"{c.GREEN}Done.{c.RESET}")
        
        if state_changed:
            self.state_manager.save(state)
            added_count = len([p for p in package_names if p.strip() in state['dependencies']])
            if added_count > 0:
                print(f"\n{c.GREEN}Added {added_count} packages to dependencies{c.RESET}")
    
    def cmd_remove_package(self, package_name: str):
        """Remove package from dependencies and mark for cleanup"""
        state = self.state_manager.load()
        
        clean_name = package_name.strip()
        removed_from = []
        
        if clean_name in state['dependencies']:
            state['dependencies'].remove(clean_name)
            removed_from.append("dependencies")
            print(f"{c.YELLOW}{clean_name} removed from dependencies{c.RESET}")
        
        if clean_name in state['tentative']:
            state['tentative'].remove(clean_name)
            removed_from.append("tentative list")
            print(f"{c.YELLOW}{clean_name} removed from tentative list{c.RESET}")
        
        if not removed_from:
            print(f"{c.YELLOW}{clean_name} was not tracked in this project{c.RESET}")
            return
        
        if clean_name not in state['cleanup']:
            state['cleanup'].append(clean_name)
            print(f"{c.BLUE}{clean_name} added to cleanup list (will be marked auto on next install){c.RESET}")
        
        self.state_manager.save(state)
        print(f"{c.GREEN}Removed {clean_name} from {' and '.join(removed_from)}{c.RESET}")
    
    def cmd_eval(self, package_name: str):
        """Add package to tentative list (evaluating)"""
        state = self.state_manager.load()
        
        if not state['project']['name']:
            print(f"{c.RED}Error: No project initialized{c.RESET}")
            print(f"{c.DIM}Hint: Run 'prp n PROJECT_NAME' first{c.RESET}")
            return
        
        clean_name = package_name.strip()
        
        if clean_name not in state['tentative']:
            state['tentative'].append(clean_name)
            print(f"{c.CYAN}Adding {clean_name} to tentative list (evaluating){c.RESET}")
            print(f"{c.DIM}Use 'prp a {clean_name}' to confirm or 'prp r {clean_name}' to remove{c.RESET}")
        else:
            print(f"{c.YELLOW}{clean_name} already in tentative list{c.RESET}")
        
        self.state_manager.save(state)
    
    def cmd_status(self):
        """Show current project status"""
        if not self.state_manager.exists:
            print(f"{c.RED}No .prp project found in current directory{c.RESET}")
            print(f"{c.DIM}Hint: Run 'prp n PROJECT_NAME' to create a project{c.RESET}")
            return
        
        state = self.state_manager.load()
        project = state['project']
        
        print(f"\n{c.BOLD}{c.CYAN}Project: {project['name']}{c.RESET}")
        print(f"{c.BLUE}Package: {project['package_name']}{c.RESET}")
        
        # Dependencies
        deps = state['dependencies']
        if deps:
            print(f"\n{c.BOLD}{c.GREEN}Dependencies ({len(deps)}):{c.RESET}")
            original_state = state.get('original_state', {})
            for dep in deps:
                orig_marker = ""
                if dep in original_state:
                    orig = original_state[dep]
                    if orig['was_manual']:
                        orig_marker = f" {c.DIM}(was manual){c.RESET}"
                    elif orig['was_installed']:
                        orig_marker = f" {c.DIM}(was auto){c.RESET}"
                    else:
                        orig_marker = f" {c.DIM}(was not installed){c.RESET}"
                print(f"  {c.GREEN}✓{c.RESET} {dep}{orig_marker}")
        
        # Tentative
        tentative = state['tentative']
        if tentative:
            print(f"\n{c.BOLD}{c.YELLOW}Tentative ({len(tentative)}):{c.RESET}")
            original_state = state.get('original_state', {})
            for pkg in tentative:
                orig_marker = ""
                if pkg in original_state:
                    orig = original_state[pkg]
                    if orig['was_manual']:
                        orig_marker = f" {c.DIM}({c.GREEN}✋{c.DIM} was manual{c.RESET})"
                    elif orig['was_installed']:
                        orig_marker = f" {c.DIM}({c.BBLUE}🛠️ was auto{c.RESET})"
                    else:
                        orig_marker = f" {c.DIM}({c.YELLOW}↶ {c.YELLOW}{c.BOLD} was not installed{c.RESET})"
                print(f"  {c.YELLOW}?{c.RESET} {pkg}{orig_marker}")
        
        # Cleanup
        cleanup = state['cleanup']
        if cleanup:
            print(f"\n{c.BOLD}{c.MAGENTA}Cleanup ({len(cleanup)}):{c.RESET}")
            for pkg in cleanup:
                print(f"  {c.MAGENTA}×{c.RESET} {pkg}")
        
        # Meta-package status
        meta = state['meta_package']
        status = f"{c.GREEN}✓ installed{c.RESET}" if meta['installed'] else f"{c.RED}✗ not installed{c.RESET}"
        print(f"\n{c.BOLD}Meta-package:{c.RESET} {status}")
        
        if not deps and not tentative:
            print(f"\n{c.DIM}No dependencies tracked yet.{c.RESET}")
            print(f"{c.DIM}Use 'prp t PACKAGE' to track and install, then 'prp a' to add to dependencies{c.RESET}")
            print(f"{c.DIM}Or 'prp a PACKAGE' to add directly{c.RESET}")
        
        print()
    
    def cmd_install(self):
        """Build and install meta-package"""
        state = self.state_manager.load()
        
        if not state['project']['name']:
            print(f"{c.RED}Error: No project initialized{c.RESET}")
            return
        
        deps = state['dependencies']
        if not deps:
            print(f"{c.RED}Error: No dependencies to install{c.RESET}")
            print(f"{c.DIM}Hint: Use 'prp a PACKAGE' to add dependencies first{c.RESET}")
            return
        
        package_name = state['project']['package_name']
        version = state['meta_package']['version']
        maintainer = state['meta_package']['maintainer']
        
        print(f"{c.BLUE}Creating meta-package {package_name}...{c.RESET}")
        
        try:
            # Mark cleanup packages as auto
            cleanup = state['cleanup']
            if cleanup:
                print(f"{c.YELLOW}Marking cleanup packages as auto: {', '.join(cleanup)}{c.RESET}")
                self.platform.mark_auto(cleanup)
                state['cleanup'] = []
            
            # Build meta-package
            deb_file = self.platform.build_meta_package(package_name, deps, version, maintainer)
            print(f"{c.GREEN}Built: {deb_file}{c.RESET}")
            
            # Install meta-package
            print(f"{c.BLUE}Installing {package_name}...{c.RESET}")
            self.platform.install_package(deb_file)
            
            # Update state
            state['meta_package']['installed'] = True
            state['meta_package']['last_built'] = datetime.now().isoformat()
            self.state_manager.save(state)
            
            print(f"{c.GREEN}Done. Meta-package installed successfully!{c.RESET}")
            
            # Clean up .deb file
            deb_file.unlink()
            
        except Exception as e:
            print(f"{c.RED}Error: {e}{c.RESET}")
    
    def cmd_uninstall(self):
        """Remove meta-package and cleanup"""
        state = self.state_manager.load()
        
        if not state['project']['name']:
            print(f"{c.RED}Error: No project initialized{c.RESET}")
            return
        
        package_name = state['project']['package_name']
        
        if not state['meta_package']['installed']:
            print(f"{c.YELLOW}Meta-package not installed{c.RESET}")
        else:
            print(f"{c.BLUE}Removing {package_name}...{c.RESET}")
            self.platform.remove_package(package_name)
            
            # Restore original package states instead of marking all as auto
            all_packages = state['dependencies'] + state['tentative']
            original_state = state.get('original_state', {})
            
            packages_to_mark_auto = []
            packages_to_keep_manual = []
            
            for pkg in all_packages:
                if pkg in original_state:
                    if original_state[pkg]['was_manual']:
                        packages_to_keep_manual.append(pkg)
                    else:
                        packages_to_mark_auto.append(pkg)
                else:
                    # If we don't have original state recorded, mark as auto
                    packages_to_mark_auto.append(pkg)
            
            if packages_to_mark_auto:
                print(f"{c.YELLOW}Marking {len(packages_to_mark_auto)} packages as auto...{c.RESET}")
                self.platform.mark_auto(packages_to_mark_auto)
            
            if packages_to_keep_manual:
                print(f"{c.BLUE}Keeping {len(packages_to_keep_manual)} packages as manual (were manual before project){c.RESET}")
            
            state['meta_package']['installed'] = False
            self.state_manager.save(state)
            
            print(f"{c.GREEN}Done. Package states restored to pre-project configuration.{c.RESET}")
            print(f"{c.DIM}Run 'sudo apt autoremove' to clean up unused auto packages{c.RESET}")

def show_help():
    """Show beautiful help output"""
    help_text = f"""
{c.BOLD}{c.CYAN}PRP - Project Requirements Packager{c.RESET}
{c.DIM}A beautiful, minimal tool for tracking project dependencies{c.RESET}

{c.BOLD}Commands:{c.RESET}
  {c.BGREEN}n, new{c.RESET} PROJECT_NAME     Create new project
  {c.BGREEN}t, track{c.RESET} PACKAGE [PKG2...]  Track packages, record state & auto-install
    {c.DIM}--update            Update recorded state to current state{c.RESET}
    {c.DIM}-I, --no-install     Only track, don't install packages{c.RESET}
  {c.BGREEN}a, add{c.RESET} PACKAGE [PKG2...]    Add package(s) to dependencies  
  {c.BGREEN}a, add{c.RESET}                     Add all tentative packages
    {c.DIM}-f, --force          Force add even if package not found{c.RESET}
    {c.DIM}-m, --manual         Keep package marked as manually installed{c.RESET}
    {c.DIM}-A, --no-auto        Don't change package's manual/auto status{c.RESET}
  {c.BGREEN}r, remove{c.RESET} PACKAGE       Remove from dependencies & mark for cleanup
  {c.BGREEN}e, eval{c.RESET} PACKAGE         Add to tentative list (evaluating)
  {c.BGREEN}s, status{c.RESET}               Show current project status
  {c.BGREEN}install{c.RESET}                 Build & install meta-package
  {c.BGREEN}uninstall{c.RESET}               Remove meta-package & cleanup

{c.BOLD}Safe workflow (preserves pre-project package states):{c.RESET}
  {c.CYAN}$ prp n mediapipe{c.RESET}                           {c.DIM}# Start new project{c.RESET}
  {c.CYAN}$ prp t libjpeg-dev libpng-dev{c.RESET}              {c.DIM}# Track & auto-install{c.RESET}
  {c.CYAN}$ prp a{c.RESET}                                     {c.DIM}# Add all tentative (respects original state){c.RESET}
  {c.CYAN}$ prp install{c.RESET}                               {c.DIM}# Create & install meta-package{c.RESET}

{c.BOLD}Track without installing:{c.RESET}
  {c.CYAN}$ prp t libjpeg-dev -I{c.RESET}                      {c.DIM}# Track only, don't install{c.RESET}

{c.BOLD}Update tracking after system changes:{c.RESET}
  {c.CYAN}$ prp t libjpeg-dev --update{c.RESET}                {c.DIM}# Update recorded state to current{c.RESET}

{c.BOLD}Quick workflow:{c.RESET}
  {c.CYAN}$ prp a libjpeg-dev libpng-dev libtiff-dev{c.RESET}  {c.DIM}# Add multiple packages{c.RESET}

{c.DIM}State stored in ./.prp/state.yaml{c.RESET}
"""
    print(help_text)

def main():
    if len(sys.argv) == 1:
        show_help()
        return
    
    prp = PRP()
    
    command = sys.argv[1].lower()
    args = sys.argv[2:]
    
    # Command aliases
    if command in ['n', 'new']:
        if len(args) < 1:
            print(f"{c.RED}Error: Project name required{c.RESET}")
            print(f"{c.DIM}Usage: prp n PROJECT_NAME{c.RESET}")
            return
        prp.cmd_new(args[0])
    
    elif command in ['a', 'add']:
        # Handle 'prp a' with no arguments - add all tentative
        if len(args) == 0:
            prp.cmd_add_tentative()
            return
            
        # Parse flags for add command
        packages = []
        flags = []
        for arg in args:
            if arg.startswith('-'):
                flags.append(arg)
            else:
                packages.append(arg)
        
        if not packages:
            print(f"{c.RED}Error: No package names provided{c.RESET}")
            return
            
        force = '-f' in flags or '--force' in flags
        manual = '-m' in flags or '--manual' in flags
        no_auto = '-A' in flags or '--no-auto' in flags
        
        prp.cmd_add(packages, force=force, manual=manual, no_auto=no_auto)
    
    elif command in ['t', 'track']:
        if len(args) < 1:
            print(f"{c.RED}Error: Package name(s) required{c.RESET}")
            print(f"{c.DIM}Usage: prp t PACKAGE [PACKAGE2 ...] [--update] [-I|--no-install]{c.RESET}")
            return
        
        # Parse flags and packages
        packages = []
        update = False
        no_install = False
        for arg in args:
            if arg == '--update':
                update = True
            elif arg in ['-I', '--no-install']:
                no_install = True
            elif not arg.startswith('-'):
                packages.append(arg)
        
        if not packages:
            print(f"{c.RED}Error: No package names provided{c.RESET}")
            return
            
        prp.cmd_track(packages, update=update, no_install=no_install)
    
    elif command in ['r', 'remove']:
        if len(args) < 1:
            print(f"{c.RED}Error: Package name required{c.RESET}")
            print(f"{c.DIM}Usage: prp r PACKAGE{c.RESET}")
            return
        prp.cmd_remove_package(args[0])
    
    elif command in ['e', 'eval']:
        if len(args) < 1:
            print(f"{c.RED}Error: Package name required{c.RESET}")
            print(f"{c.DIM}Usage: prp e PACKAGE{c.RESET}")
            return
        prp.cmd_eval(args[0])
    
    elif command in ['s', 'status']:
        prp.cmd_status()
    
    elif command == 'install':
        prp.cmd_install()
    
    elif command == 'uninstall':
        prp.cmd_uninstall()
    
    else:
        print(f"{c.RED}Unknown command: {command}{c.RESET}")
        show_help()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{c.YELLOW}Interrupted{c.RESET}")
        sys.exit(1)
    except Exception as e:
        print(f"{c.RED}Unexpected error: {e}{c.RESET}")
        sys.exit(1)
